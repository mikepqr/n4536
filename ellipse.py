# Python code for reading in the output of the IRAF ellipse task 
# (stsdas.analysis.isophote package), as translated into text-file
# output by the tprint task.
# 
# Also some functions for plotting, using the matplotlib pylab module.

# In addition, we include some functions for converting between IRAF
# ellipse-fit output and the (shortened) output of the Bender ellipse-fitting
# code -- specifically, the condensed output generated by Roberto Saglia
# as input for the Magorrian deprojection code.  (This is *not* the full
# set of measurements generated by the Bender code, by any means!)
# Example: ~/python/bender_magorrian_example.dat
# 

import math, copy
import numpy as N
import matplotlib.pyplot as p

import spline
import datautils as du

DEFAULT_BENDER_COLUMNS = ['a', 'b', 'sb', 'eps', 'deps', 'pa', 'dpa', 'a2', 'a4', 'a6', 'a8', 'a10', 'a12', 't']
COLUMNS_BENDER = "#   a        b         sb     eps  deps     pa      dpa      a2       a4       a6       a8       a10      a12      t\n"
                  
OUTPUT_FMT_BENDER_ALL = "%8.4f %8.4f  %8.4f  %.3f %.3f  %6.2f  %6.2f %8.3f %8.3f %8.3f %8.3f %8.3f %8.3f %8.3f\n"

BENDER_COLUMNS_AS_IRAF = ['sma', 'sb', 'ellip', 'ellip_err', 'pa', 'pa_err', 'b4', 'b6', 'b8',
							'b10', 'b12']

# the following is the set of standard IRAF ellipse-fit columns, *including* some
# optional column names corresponding to Bender-style ellipse fits
IRAF_COLNAMES_B = ['sma', 'intens', 'int_err', 'pix_var', 'rms', 'ellip', 'ellip_err',
	'pa', 'pa_err', 'x0', 'x0_err', 'y0', 'y0_err', 'grad', 'grad_err', 'grad_r_err', 'rsma', 
	'mag', 'mag_lerr', 'mag_uerr', 'tflux_e', 'tflux_c', 'tmag_e', 'tmag_c', 'npix_e', 'npix_c', 
	'a3', 'a3_err', 'b3', 'b3_err', 'a4', 'a4_err', 'b4', 'b4_err', 'ndata', 'nflag', 'niter', 
	'stop', 'a_big', 'sarea', 'raw_pa', 'sma_pix', 'sb', 'b6', 'b6_err', 'b8', 'b8_err',
	'b10', 'b10_err', 'b12' 'b12_err']

# the following columns are integer-valued
integerColumns = ["row", "ndata", "nflag", "niter", "stop"]

pixelScales = { "WIYN": 0.2, "PC2": 0.0455, "PC1": 0.043, "WF": 0.1,
				"NIC3": 0.2, "NIC2": 0.075, "NIC1": 0.043, "ACSWFC": 0.05,
				"ACSHRC": 0.025, "DSS": 1.7, "Alfosc": 0.188,
				"OldAlfosc": 0.189, "SDSS": 0.396, "INTWFC": 0.331 }

HIGHER_HARMONIC_RAWNAMES = ["ai5", "bi5", "ai6", "bi6", "ai7", "bi7",
							"ai8", "bi8"]
SCALED_NAMES = {"ai5": "a5", "bi5": "b5", "ai6": "a6", "bi6": "b6", 
				"ai7": "a7", "bi7": "b7", "ai8": "a8", "bi8": "b8"}


def EllipseCircum( a, b ):
	"""Calcluate circumference of an ellipse with semi-major axis a and
	semi-minor axis b, using the approximation of Ramanujan."""
	
	return math.pi * ( 3*(a + b) - math.sqrt( (3*a +  b)*(a + 3*b) ) )


def EllipseR( a, ellipticity, pa, referencePA ):
	"""Given an ellipse with specified semi-major axis, ellipticity, and
	position angle (a, ellipticity, pa), determine the radius where a
	line from the center of the ellipse at position angle = referencePA 
	intersects the ellipse.  Angles are assumed to be in degrees."""
	
	b = a*(1.0 - ellipticity)
	dPA_rad = N.radians(pa - referencePA)
	
	return 1.0 / N.sqrt( (N.cos(dPA_rad)/a)**2 + (N.sin(dPA_rad)/b)**2 )
	


def CorrectPosAngle( posAngle, telescopePA=None, flipFlag=False ):
	"""Correct position angles from IRAF ellipse format (-90 < PA < +90)
	to astronomical format (0 < PA < 180).
	"""
	
	# copy list into NumPy array
	PA = N.array(posAngle)
	nVals = len(posAngle)
	negVals = PA < 0.0
	PA[negVals] = 180 - N.abs(PA[negVals])
	if flipFlag:
		PA = 180.0 - PA
	
	if telescopePA is not None:
		if telescopePA >= 180.0:
			telescopePA -= 180.0
		newPA = PA + telescopePA
		bigVals = newPA >= 360.0
		newPA[bigVals] = newPA[bigVals] - 360.0
		bigVals = newPA >= 180.0
		newPA[bigVals] = newPA[bigVals] - 180.0
	else:
		newPA = PA
	
	return list(newPA)




def _ReadEllipse_tprint( lines ):
	"""Utility function to read an IRAF ellipse fit in tprint-generated text-file
	form (supplied as a list of lines read in from the file).  Output is a tuple of
	(dictionary containing the columns, list of lower-cased column names).
	"""

	commentlines = [line.strip() for line in lines if line[0] == "#"]
	# skip first comment line
	nBlocks = len(commentlines[1:]) / 2
	columnNameLines = [ commentlines[2*i + 1] for i in range(nBlocks) ]

	datalines = [line.strip() for line in lines if line[0] not in ["#", "\n"] ]
	nPts = len(datalines)/nBlocks
	
	dataDict = {}
	columnNameList = []
	
	for i in range(nBlocks):
		pp = columnNameLines[i].split()
		colNames = [ name.lower() for name in pp[1:] ]
		nCols = len(colNames)
		for colname in colNames:
			if colname != "row":
				dataDict[colname] = []
				columnNameList.append(colname)
		
		for j in range(nPts):
			dataline = datalines[nPts*i + j]
			datapieces = dataline.split()
			for cc in range(nCols):
				colName = colNames[cc]
				dataPiece = datapieces[cc]
				if colName != "row":
					if colName in integerColumns:
						try:
							dataVal = int(dataPiece)
						except ValueError:
							print(dataline)
							print(dataPiece)
							raise
					else:
						try:
							dataVal = float(dataPiece)
						except ValueError, e:
							if dataPiece == "INDEF":
								dataVal = 0.0
							else:
								raise ValueError, e
					dataDict[colName].append(dataVal)	

	return dataDict, columnNameList


def _ReadEllipse_tdump( lines ):
	"""Utility function to read an IRAF ellipse fit in tdump-generated text-file
	form (supplied as a list of lines read in from the file).  Output is a tuple of
	(dictionary containing the columns, list of lower-cased column names, name of
	original fitted image).
	"""

	for i in range(len(lines)):
		if lines[i].startswith("IMAGE"):
			lastHeader = i
	
	colHeaderlines = lines[0:lastHeader]   # very last "header" line is IMAGE name
	imageName = lines[lastHeader].split()[-1].strip()
	datalines = lines[lastHeader + 1:]
	nDataRows = len(datalines)

	columnNameList = [ line.split()[0].lower() for line in colHeaderlines ]

	nColumns = len(colHeaderlines)
	nElements = len(datalines[0].split())
	if (nElements != nColumns):
		msg = "ERROR: Number of column titles (%d) not equal to number of columns (%d)!" % (nElements, nColumns)
		print(msg)
		return None, None
	dataList = []
	for i in range(nColumns):
		dataList.append([])
	# go through the table and assign entries to individual-column lists
	for n in range(nDataRows):
		pieces = datalines[n].split()
		for i in range(nColumns):
			colName = columnNameList[i]
			dataPiece = pieces[i]
			if colName in integerColumns:
				try:
					dataVal = int(dataPiece)
				except ValueError:
					print(datalines[n])
					print(dataPiece)
					raise ValueError, e
			else:
				try:
					dataVal = float(dataPiece)
				except ValueError, e:
					if dataPiece == "INDEF":
						dataVal = 0.0
					else:
						raise ValueError, e
			dataList[i].append(dataVal)
	
	# create dictionary and assign columns to column names
	dataDict = {}
	for i in range(nColumns):
		dataDict[columnNameList[i]] = dataList[i]
	
	return dataDict, columnNameList, imageName

	
def ReadEllipse( filename, pix=1.0, dataFrame=True, correctPA=True,
					telPA=None, obs=None, flip=False, ZP=None ):
	"""Read in an ellipse fit and store it in a dictionary (or, optionally,
	a ListDataFrame object). The original column names are transformed into
	lower-case (e.g., ELLIP_ERR --> ellip_err). All columns are converted to
	1-D Numpy arrays.
	
	The ellipse fit is assumed to be a text file which has been generated
	from the original STSDAS-table file via either "tprint" or "tdump".
	
	If the requested output is a ListDataFrame object, then a few additional 
	entries/attributs are defined: dataframe.filename has the path to
	the original text file, dataframe.arcsec_per_pix has the user-supplied
	pixel scale, and dataframe.image has the original fitted image name *if*
	the ellipse it was in tdump format (tprint format does not preserve that
	information).  In addition, the ListDataFrame object will have additional
	alternate column names "a" for "SMA" and "i" for "INTENS".
	
	If correctPA = True [the default], then position angles are corrected
	from ellipse values (-90 < pa < +90) to normal astronomical values.
	
	obs can be used to pass strings referring to different instruments/
	telescopes, e.g. "WIYN", "NIC1", "WFPC2", "ACSWFC", etc.  These map to
	the appropriate pixel scales.
	
	flip=True to force flipping of PA values about the y-axis (e.g., for WIYN
	or other imagers with E-W orientation flipped).
	
	If ZP is given, then it is treated as an effective zero point for converting
	measured counts/pixel ("intensity", which is the 'INTENS' column in the original 
	ellipse fits) to mag arcsec^-2:
		mu = ZP - 2.5 log10(intensity)
	This zero point should incorporate any necessary conversions (e.g., pixel area
	to arcsec^2, exposure time). A new column (named 'sb') is added to the ellipse-fit
	dictionary or object.
	"""
	
	lines = open(filename).readlines()
	
	# identify whether it's tprint or tdump output
	if lines[0].startswith("#  Table"):
		# table was generated by tprint
		dataDict, columnNameList = _ReadEllipse_tprint(lines)
		originalImage = None
	elif lines[0].startswith("SMA              R           %7.2f  pixel"):
		# table was generated by tdump
		dataDict, columnNameList, originalImage = _ReadEllipse_tdump(lines)
	
	
	# Post-processing:
	# correct PA:
	dataDict["raw_pa"] = dataDict["pa"]
	dataDict["pa"] = CorrectPosAngle(dataDict["pa"], telPA, flip)
	
	# change SMA value from pixels to arcsec:
	dataDict["sma_pix"] = dataDict["sma"]
	dataDict["sma"] = [ pix*sma for sma in dataDict["sma"] ]
	# provide more useful/predictable intensity-error key:
	dataDict["intens_err"] = dataDict["int_err"]
	# add list of column names in original order
	columnNameList.append("raw_pa")
	columnNameList.append("sma_pix")
	
	# compute correct higher-order harmonic values, if present:
	higherHarmonicsPresent = False
	for rawnameHH in HIGHER_HARMONIC_RAWNAMES:
		if rawnameHH in columnNameList:
			higherHarmonicsPresent = True
	if higherHarmonicsPresent is True:
		sma = N.array(dataDict["sma_pix"])
		gradient = N.array(dataDict["grad"])
		sma_times_grad = sma*gradient
		for rawHarmonic in HIGHER_HARMONIC_RAWNAMES:
			if rawHarmonic in columnNameList:
				rawData = N.array(dataDict[rawHarmonic])
				rawErr = N.array(dataDict[rawHarmonic + "_err"])
				scaledData = rawData / sma_times_grad
				scaledErr = rawErr / sma_times_grad
				scaledName = SCALED_NAMES[rawHarmonic]
				scaledErrName = scaledName + "_err"
				dataDict[scaledName] = scaledData
				dataDict[scaledErrName] = scaledErr
				columnNameList.append(scaledName)
				columnNameList.append(scaledErrName)
	
	# Convert all columns to Numpy arrays
	for cname in columnNameList:
		dataDict[cname] = N.array(dataDict[cname])
	
	if ZP is not None:
		dataDict["sb"] = ZP - 2.5*N.log10(dataDict['intens'])
		columnNameList.append("sb")

	dataDict["column_list"] = columnNameList
			
	# Convert to dataFrame, if requested:
	if dataFrame is True:
		frameList = []
		for cname in columnNameList:
			frameList.append(dataDict[cname])
		result = du.ListDataFrame(frameList, columnNameList)
		# extra conveninces
		result.AddColumnName("sma", "a")
		result.AddColumnName("intens", "i")
		# add meta-data
		result.tableFile = filename
		result.arcsec_per_pix = pix
		result.origImage = originalImage
	else:
		result = dataDict
		
	return result



def ReplaceColumnsWithConstants( efit, colNameList, colValueList, smarange=None ):
	"""Given an ellipse-fit dictionary, for each column name in colNameList,
	replace the existing values with the corresponding constant value in colValueList.
	Optionally, the range in semi-major axis for which values are replaced can be 
	specified via smarange (only semi-major axis values >= smarange[0] and 
	<= smarange[1] will be affectd).
	"""
	
	if "sma" in efit.keys():
		# IRAF-style ellipse fit
		a = efit['sma']
	else:
		# probably Bender-format ellipse fit
		if 'a' in efit.keys():
			a = efit['a']
		elif 'r' in efit.keys():
			a = efit['r']
		else:
			print("UNABLE TO FIND SMA COLUMN IN ELLIPSE-FIT DICTIONARY!")
			return None
	nRows = len(a)
	N = len(colNameList)
	
	if smarange is not None:
		amin = smarange[0]
		amax = smarange[1]
		iGood = [ i for i in range(nRows) if a[i] >= amin and a[i] <= amax ]
	else:
		iGood = range(nRows)
		
	for i in iGood:
		for j in range(N):
			efit[colNameList[j]][i] = colValueList[j]



def MergeEllipseFits( efit1, efit2, transitionRadius ):
	"""Given two IRAF-style ellipse-fit dictionaries (efit1 and efit2), return a 
	merged ellipse-fit dictionary where data from efit1 is used for a < transitionRadius
	and data from efit2 is used for a > transitionRadius.
	"""
	
	newDict = {}
	columnNameList = efit1["column_list"]
	a1 = efit1['sma']
	a2 = efit2['sma']
	n1 = len(a1)
	n2 = len(a2)
	# check for bad inputs
	if (transitionRadius < a1[0]) or (transitionRadius > a1[-1]):
		print("Requested transition radius (%g) is outside boundaries of efit1 (%g--%g)!" % (transitionRadius,
					a1[0], a1[-1]))
		return None
	if (transitionRadius < a2[0]) or (transitionRadius > a2[-1]):
		print("Requested transition radius (%g) is outside boundaries of efit2 (%g--%g)!" % (transitionRadius,
					a2[0], a2[-1]))
		return None

	efit1_border = NearestIndex(a1, transitionRadius, noprint=True)
	efit2_border = NearestIndex(a2, transitionRadius, noprint=True)
	end1 = efit1_border[1]
	start2 = efit2_border[1]
	if (a2[start2] <= a1[end1]):
		start2 += 1
	
	for colName in columnNameList:
		efit1vals = efit1[colName]
		efit2vals = efit2[colName]
		newDict[colName] = N.concatenate((efit1vals[0:end1], efit2vals[start2:]))
	newDict["column_list"] = columnNameList
	
	return newDict



def IntensityFromRadius( ellipseFit, radius, ZP=None ):
	"""
	Given user-specified radius, ellipse fits, log-scaled image: go into 
	ellipse fit and determine corresponding isophote level (spline-interpolate 
	between adjacent semi-major axes to get intensity, return log intensity or 
	zero-point-based magnitude).
	Result is intensity (counts/pixel), unless ZP is specified, in which
	case the result is in magnitudes (if ZP converts counts/pixel to mag/arcsec^2,
	the result is mag/arcsec^2).
	"""
	
	sma = N.array(ellipseFit['sma'])
	if (radius < sma[0]) or (radius > sma[-1]):
		txt = "WARNING: requested radius (%g) is" % radius
		txt += " ellipse-fit semi-major axis range (%g--%g)!" % (sma[0], sma[-1])
		print(txt)
		return None
	intensity = N.array(ellipseFit['intens'])
	intensity_spline_func = spline.Spline(sma, intensity)
	newIntensity = intensity_spline_func(radius)
	if ZP is None:
		return newIntensity
	else:
		return (ZP - 2.5*math.log10(newIntensity))



def GetIntensityReq( ellipseFit, mode="iraf" ):
	"""
	Given user-specified ellipse fit (defaults to iraf format, but mode="bender"
	can be used to indicate a Bender/Saglia format), return tuple of equivalent radius
	(r_eq = sqrt(a*b)) vector and intensities/surface-brightness vector (for iraf-
	format ellipse fits, we return the intensities; for Bender/Saglia format, we
	return the "surface brightness").
	"""
	
	if mode == "iraf":
		aKey = "sma"
		ellKey = "ellip"
		iKey = "intens"
	elif mode == "bender":
		aKey = "a"
		ellKey = "eps"
		iKey = "sb"
	sma = N.array(ellipseFit[aKey])
	ell = N.array(ellipseFit[ellKey])
	i_or_mu = N.array(ellipseFit[iKey])
	req = sma * N.sqrt(1.0 - ell)
	return (req, i_or_mu)

	

def WriteProfile( x, y, outputFilename ):
	"""Take two input vectors x and y (integer or float) and write them 
	to a text file:
		   x    y
	"""
	
	nX = len(x)
	nY = len(y)
	if (nX != nY):
		msg = "WARNING: number of elements in x (%d) not same as number" % nX
		msg += " of elements in y (%d)!\n" % nY
		msg += "Nothing saved.\n"
		print(msg)
		return
	nPts = min([nX, nY])

	outf = open(outputFilename, 'w')
	for i in xrange(nPts):
		outf.write("%g\t\t%g\n" % (x[i], y[i]))
	outf.close()
	return



def WriteProfileFromDict( dataDict, outputFilename ):
	"""Take a data dictionary from an ellipse fit and save I(a) in a text file:
		   a    I(a)
	"""
	
	sma = dataDict["sma"]
	I = dataDict["intens"]
	WriteProfile(sma, I, outputFilename)
	return



def NearestIndex( vector, value, noprint=False, debug=0 ):
	"""Given an input list (or Numeric-style 1-D array), which is asumed to be 
	monotonically increasing or decreasing, find the indices of the two points 
	with values closest	to parameter 'value'."""
	
	npts = len(vector)
	
	if (value < min(vector)) or (value > max(vector)):
		if noprint:
			return (None, None)
		else:
			print("   value %f lies outside range of input vector (%g to %g)!" % \
					(value, min(vector), max(vector)))
			return None
	
	diff1 = vector[1] - vector[0]
	if diff1 > 0:
		# vector is increasing
		Sign = 1
	else:
		# vector is decreasing
		Sign = -1
	i1 = i2 = 0
	diff = Sign*(value - vector[0])
	if debug: print(diff)
	for i in range(1, npts):
		if debug: print(i)
		newdiff = Sign*(value - vector[i])
		if debug: print(newdiff)
		if (newdiff > 0) and (newdiff <= diff):
			diff = newdiff
			i1 = i
		else:
			# we just crossed over
			i2 = i
			break
	if noprint:
		return (i1, i2)
	else:
		print("   input_vector[%d,%d] = %g, %g" % (i1, i2, vector[i1], vector[i2]))



def WeightedFlux( dataDict ):
	"""Given an input ellipse-fit stored in a dictionary, compute the approximate
	total flux."""
	
	sma = dataDict["sma"]
	I = dataDict["intens"]
	ellipticity = dataDict["ellip"]
	npts = len(sma)
	
	# start with flux inside innermost ellipse
	innerFlux = dataDict["TFLUX_E"][0]
	fluxSum = innerFlux
	# now add up flux in elliptical annuli
	for j in range(1, npts - 1):
		dr = (sma[j + 1] - sma[j - 1])/2.0
		# approximation to circumference of ellipse
		a = sma[j]
		b = a*(1.0 - ellipticity[j])
		area = EllipseCircum(a,b) * dr
		fluxSum += I[j]*area
	# add outermost ellipse
	dr = sma[npts - 1] - sma[npts - 2]
	a = sma[npts - 1]
	b = a*(1.0 - ellipticity[npts - 1])
	area = EllipseCircum(a,b)
	fluxSum += I[npts - 1]*area
	
	return fluxSum



def EquivRadius( dataDict ):
	"""Given an input ellipse-fit stored in a dictionary, return a NumPy array
	of the equivalent radius [r_eq = sqrt(a*b)]."""
	
	a = N.array(dataDict["sma"])
	ellipticity = N.array(dataDict["ellip"])
	b = (1.0 - ellipticity)*a
	r_eq = N.sqrt(a*b)
	return r_eq



# PLOTTING FUNCTIONS:

def PlotValsErrors( efit, valName, smaName='sma', errPrefix=None, errSuffix="_err", 
					xlog=False, ylog=False, xmark=None, flipPA=None, plotColor="k",
					ymark=None, ymarkColor='k' ):
	"""Plot a parameter from an ellipse fit, along with its errors,
	against semi-major axis (default assumes that semi-major axis is accessed via
	efit['sma'], but user can specify a different key via smaName).
	valName = string containing name of parameter (e.g., "ellip", "pa"); error is
	assumed to be referenced by valame + errSuffix (but this can be changed to use a
	prefix string).
		flipPA: assuming that valName corresponds to position angles,
	rearrange PA values so that PA > flipPA are set negative; PA values
	below flipPA are unchanged (useful for those cases when PA wraps
	around past 180).  If flipPA < 0, then values of PA < abs(flipPA) have
	180 added to them.
	"""
	
	if errPrefix is not None:
		valErrName = errPrefix + valName
	else:
		valErrName = valName + errSuffix
	a = N.array(efit[smaName])
	y = N.array(efit[valName])
	y_err = N.array(efit[valErrName])
	if flipPA is not None:
		if flipPA >= 0:
			makeNeg = y >= flipPA
			y[makeNeg] = y[makeNeg] - 180.0
		else:
			makePos = y <= N.abs(flipPA)
			y[makePos] = y[makePos] + 180.0
	if xlog is True and ylog is False:
		p.semilogx(a, y, color=plotColor)
	elif xlog is False and ylog is True:
		p.semilogy(a, y, color=plotColor)
	elif xlog is True and ylog is True:
		p.loglog(a, y, color=plotColor)
	else:
		p.plot(a, y, color=plotColor)
	p.errorbar(a, y, yerr=y_err, fmt="o", color=plotColor, ms=2)
	if xmark is not None:
		if type(xmark) in [int, float]:
			p.axvline(xmark, ls="--", color="k")
		else:
			for x in xmark:
				p.axvline(x, ls="--", color=ymarkColor)
	if ymark is not None:
		if type(ymark) in [int, float]:
			p.axhline(ymark, ls="--", color=ymarkColor)
		else:
			for y in ymark:
				p.axhline(y, ls="--", color=ymarkColor)


def PlotEllPA( efit, xlog=False, xrange=None, parange=None, erange=None,
				xmark=None, pamark=None, ellmark=None, flipPA=None, merge=False, efit2=None,
				maintitle=None, xtitle="Semi-major axis", plotColorList=['k', 'r', 'g', 'b'],
				noErase=False):
	"""Plot position angle and ellipticity for one or more ellipse-fit objects,
	with PA in upper panel and ellipticity in lower panel.  efit can be a single
	ellipse-fit object [generated by ReadEllipse] or a list of such objects.
		flipPA: rearrange PA values so that PA > flipPA are
	set negative; PA values below flipPA are unchanged (useful for those
	cases when PA wraps around past 180).  If flipPA < 0, then values
	of PA < abs(flipPA) have 180 added to them.
		xmark: can be a single number or a list of numbers; vertical dashed
	lines will be drawn at the corresponding semi-major axis value(s).
		pamark, ellmark: single number or list of numbers; horizontal dashed lines
	will be drawn for the corresponding values of PA or ellipticity.
		plotColorList = optional list of color specifications for use when plotting
	a list of ellipse-fit objects.
	"""
	
	if isinstance(efit, list):
		nEfits = len(efit)
		plotList = True
	else:
		plotList = False

	if noErase is False:
		p.clf()
	
	if merge is True:
		# This code is somewhat out-of-date [doesn't handle lists of efit objects]
		# do clever axes stuff here
		ax1 = p.axes([0.2, 0.5, 0.6, 0.4])
		ax1.set_xticklabels([])
		PlotValsErrors(efit, "pa", xlog=xlog, xmark=xmark, ymark=pamark, flipPA=flipPA)
		if efit2 is not None:
			PlotValsErrors(efit2, "pa", xlog=xlog, xmark=xmark, flipPA=flipPA, plotColor="g")
		p.ylabel("Position Angle")
		ax2 = p.axes([0.2, 0.1, 0.6, 0.4])
		PlotValsErrors(efit, "ellip", xlog=xlog, ymark=ellmark, xmark=xmark)
		if efit2 is not None:
			PlotValsErrors(efit2, "ellip", xlog=xlog, xmark=xmark, plotColor="g")
		p.ylabel(r"Ellipticity = $1 - b/a$")
		p.xlabel("Semi-major axis")
# 	ax1 = p.subplot(211)
# 	if merge is True:
# 		ax1.set_xticks([])

	else:
		ax1 = p.subplot(211)
		if not plotList:
			PlotValsErrors(efit, "pa", xlog=xlog, xmark=xmark, ymark=pamark, flipPA=flipPA, plotColor=plotColorList[0])
		else:
			for i in range(nEfits):
				PlotValsErrors(efit[i], "pa", xlog=xlog, xmark=xmark, ymark=pamark, flipPA=flipPA,
								plotColor=plotColorList[i])
		p.ylabel("Position Angle")
		if (xrange is not None):
			p.xlim(xrange[0], xrange[1])
		if (parange is not None):
			p.ylim(parange[0], parange[1])
		if maintitle is not None:
			p.title(maintitle)
		ax2 = p.subplot(212)
		if not plotList:
			PlotValsErrors(efit, "ellip", xlog=xlog, xmark=xmark, ymark=ellmark, plotColor=plotColorList[0])
		else:
			for i in range(nEfits):
				PlotValsErrors(efit[i], "ellip", xlog=xlog, xmark=xmark, ymark=ellmark,
								plotColor=plotColorList[i])
		if (xrange is not None):
			p.xlim(xrange[0], xrange[1])
		if (erange is not None):
			p.ylim(erange[0], erange[1])
		p.ylabel(r"Ellipticity = $1 - b/a$")
		p.xlabel(xtitle)

        return (ax1, ax2)
	

def PlotHigher( efit, m=4, xlog=False, xrange=None, arange=None, brange=None,
				xmark=None, merge=False, efit2=None,
				maintitle=None, xtitle="Semi-major axis", plotColorList=['k', 'r', 'g', 'b']):
	"""Plot higher-order harmonics (e.g., A_4 and B_4) for one or more ellipse-fit
	objects, with A_m in upper panel and B_m in lower panel.  Meant for use with IRAF
	ellipse fits.  efit can be a single ellipse-fit object [generated by ReadEllipse]
	or a list of such objects.
		Defaults to m=4.
		plotColorList = optional list of color specifications for use when plotting
	a list of ellipse-fit objects.
	"""
	
	if isinstance(efit, list):
		nEfits = len(efit)
		plotList = True
	else:
		plotList = False

	if (m < 3) or (m > 8):
		if (m < 3):
			print("*** WARNING: m < 3 harmonic components not defined! ***")
		else:
			print("*** WARNING: m > 8 harmonic components not currently supported! ***")
		return None
	sinHarmonicName = "a%1d" % m
	sinHarmonicLabel = "A%1d" % m
	cosHarmonicName = "b%1d" % m
	if (m == 4):
		cosHarmonicLabel = r"[boxy] -- B4 -- [disky]"
	else:
		cosHarmonicLabel = "B%1d" % m
	p.clf()
	if merge is True:
		# This code is somewhat out-of-date [doesn't handle lists of efit objects]
		# do clever axes stuff here
		ax1 = p.axes([0.2, 0.5, 0.6, 0.4])
		ax1.set_xticklabels([])
		PlotValsErrors(efit, sinHarmonicName, xlog=xlog, xmark=xmark)
		if efit2 is not None:
			PlotValsErrors(efit2, sinHarmonicName, xlog=xlog, xmark=xmark, plotColor="g")
		p.ylabel(sinHarmonicLabel)
		ax2 = p.axes([0.2, 0.1, 0.6, 0.4])
		PlotValsErrors(efit, cosHarmonicName, xlog=xlog, xmark=xmark)
		if efit2 is not None:
			PlotValsErrors(efit2, cosHarmonicName, xlog=xlog, xmark=xmark, plotColor="g")
		py.ylabel(cosHarmonicLabel)
		p.xlabel("Semi-major axis")
	else:
		p.subplot(211)
		if not plotList:
			PlotValsErrors(efit, sinHarmonicName, xlog=xlog, xmark=xmark)
		else:
			for i in range(nEfits):
				PlotValsErrors(efit[i], sinHarmonicName, xlog=xlog, xmark=xmark,
								plotColor=plotColorList[i])
		if xrange is None:
			xrange = p.xlim()
		p.ylabel(sinHarmonicLabel)
		p.plot([xrange[0], xrange[1]], [0,0], 'k')
		if (xrange is not None):
			p.xlim(xrange[0], xrange[1])
		if (arange is not None):
			p.ylim(arange[0], arange[1])
		if maintitle is not None:
			p.title(maintitle)
		p.subplot(212)
		if not plotList:
			PlotValsErrors(efit, cosHarmonicName, xlog=xlog, xmark=xmark)
		else:
			for i in range(nEfits):
				PlotValsErrors(efit[i], cosHarmonicName, xlog=xlog, xmark=xmark,
								plotColor=plotColorList[i])
		p.plot([xrange[0], xrange[1]], [0,0], 'k')
		if (xrange is not None):
			p.xlim(xrange[0], xrange[1])
		if (brange is not None):
			p.ylim(brange[0], brange[1])
		p.ylabel(cosHarmonicLabel)
		p.xlabel(xtitle)
	


def doplot( efit, xmark=None, expfit=None, zp=None, title=None, filter="R",
			sigma=None, noErase=False ):
	"""Plot an ellipse-fit profile (intensity vs radius), with log-scaling on
	y axis.  Optionally, a set of radii to mark with vertical dotted lines can
	be supplied  (xmark), one or more exponential fit can be plotted as well
	(the exponential fit should be supplied as a list: [I_0, h] or 
	[I_1, h_1, I_2, h_2, ...].  If a zero point is suppled (zp), then the
	intensities are converted to magnitudes."""
	
	xt = "Radius [arc sec]"
	yt = "Intensity [ADU/pixel]"
	
	if noErase is False:
		p.clf()
	rr = N.array(efit["sma"])
	ii = N.array(efit["intens"])
	
	min_i = min(ii)
	max_i = max(ii)
	if min(ii) < 0:
		min_i = min([x for x in ii if x > 0])

	if zp is not None:
		mags = zp - 2.5*N.log10(ii)
		min_y = math.ceil(zp - 2.5*math.log10(min_i))
		max_y = math.floor(zp - 2.5*math.log10(max_i))
	else:
		# round minimum and maximum values to nearest power of ten (round up
		# for maximum, round down for minimum)
		min_y = 10.0**math.floor(math.log10(min_i))
		max_y = 10.0**math.ceil(math.log10(max_i))
	if zp is not None:
		p.plot(rr, mags)
	else:
		p.semilogy(rr, ii)
	if expfit is not None:
		nfits = len(expfit)/2
		for j in range(nfits):
			I0 = expfit[j*2]
			h = expfit[j*2 + 1]
			fitflux = I0*N.exp(-rr/h)
			if zp is not None:
				p.plot(rr, zp - 2.5*N.log10(fitflux), color="g")
			else:
				p.semilogy(rr, fitflux, color="g")
		
	if xmark is not None:
		for xm in xmark:
			p.axvline(xm, ls=":", color="k")
	if sigma is not None:
		if zp is not None:
			limitLevel = zp - 2.5*math.log10(4.94*sigma)
		else:
			limitLevel = 4.94*sigma
		p.plot([0, rr[-1]], [limitLevel, limitLevel], "r--")
	
	if zp is not None:
		# need have y-axis in proper orientation for magnitudes
		yt = r"$\mu_{" + filter + r"} \hspace{0.5} [\rm{mag} \hspace{0.5} \rm{arcsec}^{-2}]$"
	
	p.ylim(min_y, max_y)
	p.xlabel(xt) ; p.ylabel(yt)
	if title is not None:
		p.title(title)




# Code for working with (abridged) versions of Bender ellipse-fit output

def ConvertHigherOrder_Iraf2Bender( a, ell, B_iraf, magorrianStyle=True ):
	"""Convert IRAF ellipse-fit cos(m theta) term Bm to Bender ellipse-fit
	cos(m theta) term am [really am/a].  By default, the output is in
	Magorrian-style 100 * (am/a) format.
	
	a = semi-major axis
	ell = ellipticity
	"""
	b = (1.0 - ell)*a
	am_base = N.sqrt(b/a) * B_iraf
	if magorrianStyle is True:
		return 100.0 * am_base
	else:
		return am_base

def ConvertHigherOrder_Bender2Iraf( a, ell, am, magorrianStyle=True ):
	"""Convert Bender/Saglia ellipse-fit cos(m theta) term am  [really am/a]
	to IRAF ellipse-fit cos(m theta) term Bm.  By default, the input is assumed
	to be in Magorrian-style 100 * (a4/a) format.
	
	a = semi-major axis
	ell = ellipticity
	"""
	if magorrianStyle is True:
		am_base = am/100.0
	else:
		am_base = am
	b = (1.0 - ell)*a
	Bm = am_base / N.sqrt(b/a)
	return Bm



def ReadBenderEllipse( filename, dataFrame=False, headerLine=None, useDefaultColumnNames=True ):
	"""Read in an ellipse fit generated by Bender/Saglia code and store it
	in a dictionary (or, optionally, a ListDataFrame object). Columns are
	converted to 1-D Numpy arrays.
	
	headerLine indicates which line contains the column titles (first line = 1,
	etc.); the actual data is assumed to start immediately after.
	Normally, the function attempts to locate the header line automatically
	(first line in file with same number of elements [excluding any initial "#"]
	as last line in file).  The headerLine keyword is mainly useful for perverse
	situations (e.g., there is a line in the header that happens to have 12
	words in it).
		
	Because we (currently) don't know how the Bender code handles position
	angles, we don't attempt to "correct" the PA.
	"""
	
	lines = open(filename).readlines()
	nTotalLines = len(lines)
	lastLine = lines[-1]
	nCols = len(lastLine.split())
	
	# find the header line -- should be first line which has same number of elements
	# as the last line in the file
	if headerLine is None:
		headerString = None
		for i in range(nTotalLines):
			tmpLine = lines[i].lstrip("#")
			if len(tmpLine.split()) == nCols:
				headerString = tmpLine
				headerLineIndex = i
				break
		if headerString is None:
			print("Unable to find header line!\n")
			return None
	else:
		headerLineIndex = headerLine - 1
		headerString = lines[headerLineIndex]

	if useDefaultColumnNames:
		colheaders = DEFAULT_BENDER_COLUMNS
	else:
		colheaders = headerString.split()
		# get rid of excess space at end, if any
		colheaders[-1] = colheaders[-1].strip()
	
	# find first data line:
	firstDataLine = None
	for j in range(headerLineIndex + 1, nTotalLines):
		tmpLine = lines[j]
		if len(tmpLine.split()) == nCols:
			firstDataLine = j
			break
	if firstDataLine is None:
		print("Unable to find first data line!\n")
		return None
		
	dataLines = [line for line in lines[firstDataLine:] if line[0] != "#"]
	nDataLines = len(dataLines)
	dataDict = {}
	for i in range(nCols):
		cname = colheaders[i]
		dataDict[cname] = N.array([ float(line.split()[i]) for line in dataLines ])
	
	# Convert to dataFrame, if requested:
	if dataFrame is True:
		frameList = []
		for cname in colheaders:
			frameList.append(dataDict[cname])
		result = du.ListDataFrame(frameList, colheaders)
		# extra conveninces
		#result.AddColumnName("sma", "a")
		#result.AddColumnName("intens", "i")
		# add meta-data
		result.tableFile = filename
	else:
		result = dataDict

	return result



def WriteBenderEllipse( ellipseFit, outputFilename ):
	"""Given an ellipseFit dictionary containing Bender-format entries (as generated by
	ReadBenderEllipse), write the ellipse fit to a text file.
	
	ASSUMES THAT ellipseFit IS ALREADY IN BENDER FORMAT!
	"""
	
	outputLines = [COLUMNS_BENDER, "#\n"]
	
	smaKey = 'a'
	if 'a' not in ellipseFit.keys():
		smaKey = 'r'
	nDataLines = len(ellipseFit[smaKey])
	for i in range(nDataLines):
		a = ellipseFit[smaKey][i]
		b = ellipseFit['b'][i]
		sb = ellipseFit['sb'][i]
		eps = ellipseFit['eps'][i]
		deps = ellipseFit['deps'][i]
		pa = ellipseFit['pa'][i]
		dpa = ellipseFit['dpa'][i]
		a2 = ellipseFit['a2'][i]
		a4 = ellipseFit['a4'][i]
		a6 = ellipseFit['a6'][i]
		a8 = ellipseFit['a8'][i]
		a10 = ellipseFit['a10'][i]
		a12 = ellipseFit['a12'][i]
		t = ellipseFit['t'][i]
		outLine = OUTPUT_FMT_BENDER_ALL % (a,b,sb,eps,deps,pa,dpa,a2,a4,a6,a8,a10,a12,t)
		outputLines.append(outLine)
	
	outf = open(outputFilename, 'w')
	for line in outputLines: outf.write(line)
	outf.close()


def ConvertBenderToIraf( benderEfit, dataFrame=True ):
	"""Given an ellipse-fit DataFrame object generated by reading a Bender/Saglia
	ellipse-fit file, generate a new DataFrame object in IRAF ellipse-fit format.
	
		a4,a6,a8,a10,a12 are converted to IRAF-format B4,B6,etc. (errors for these
			quantities are set to 0, since the 
	"""
	
	a = benderEfit['a']
	ell = benderEfit['eps']
	nPts = len(a)
	
	irafDict = {}
	irafDict['sma'] = benderEfit['a']
	irafDict['sb'] = benderEfit['sb']
	irafDict['ellip'] = benderEfit['eps']
	irafDict['ellip_err'] = benderEfit['deps']
	irafDict['pa'] = benderEfit['pa']
	irafDict['pa_err'] = benderEfit['dpa']
	irafDict['b4'] = ConvertHigherOrder_Bender2Iraf(a, ell, benderEfit['a4'])
	irafDict['b6'] = ConvertHigherOrder_Bender2Iraf(a, ell, benderEfit['a6'])
	irafDict['b8'] = ConvertHigherOrder_Bender2Iraf(a, ell, benderEfit['a8'])
	irafDict['b10'] = ConvertHigherOrder_Bender2Iraf(a, ell, benderEfit['a10'])
	irafDict['b12'] = ConvertHigherOrder_Bender2Iraf(a, ell, benderEfit['a12'])
	
	# add in missing columns, filled with zeros
	for cname in IRAF_COLNAMES_B:
		if cname not in BENDER_COLUMNS_AS_IRAF:
			irafDict[cname] = N.zeros(nPts)
	
	# Convert to dataFrame, if requested:
	if dataFrame is True:
		frameList = []
		columnNameList = IRAF_COLNAMES_B
		for cname in columnNameList:
			frameList.append(irafDict[cname])
		result = du.ListDataFrame(frameList, columnNameList)
		# extra conveninces
		result.AddColumnName("sma", "a")
		result.AddColumnName("intens", "i")
	else:
		result = irafDict
	
	return result
	

def ConvertIrafToBender( irafEfit, dataFrame=True ):
	"""Given an ellipse-fit DataFrame object generated by reading an IRAF
	ellipse-fit file, generate a new DataFrame object in (abridged) Bender
	ellipse-fit format.
	
		B4,B6,etc. are converted to Bender-style a4,a6,etc.
	"""
	
	a = irafEfit['a']
	ell = irafEfit['ellip']
	irafColnames = irafEfit.colNames
	nPts = len(a)
	
	benderDict = {}
	benderDict['a'] = irafEfit['a']
	benderDict['b'] = a * (1.0 - ell)
	benderDict['sb'] = irafEfit['sb']
	benderDict['eps'] = irafEfit['ellip']
	benderDict['deps'] = irafEfit['ellip_err']
	benderDict['pa'] = irafEfit['pa']
	benderDict['dpa'] = irafEfit['pa_err']
	benderDict['a2'] = N.zeros(nPts)
	benderDict['a4'] = ConvertHigherOrder_Iraf2Bender(a, ell, irafEfit['b4'])
	if 'b6' in irafColnames:
		benderDict['a6'] = ConvertHigherOrder_Iraf2Bender(a, ell, irafEfit['b6'])
	else:
		benderDict['a6'] = N.zeros(nPts)
	if 'b8' in irafColnames:
		benderDict['a8'] = ConvertHigherOrder_Iraf2Bender(a, ell, irafEfit['b8'])
	else:
		benderDict['a8'] = N.zeros(nPts)
	if 'b10' in irafColnames:
		benderDict['a10'] = ConvertHigherOrder_Iraf2Bender(a, ell, irafEfit['b10'])
	else:
		benderDict['a10'] = N.zeros(nPts)
	if 'b12' in irafColnames:
		benderDict['a12'] = ConvertHigherOrder_Iraf2Bender(a, ell, irafEfit['b12'])
	else:
		benderDict['a12'] = N.zeros(nPts)
	benderDict['t'] = N.zeros(nPts)
	
	# Convert to dataFrame, if requested:
	if dataFrame is True:
		frameList = []
		columnNameList = DEFAULT_BENDER_COLUMNS
		for cname in columnNameList:
			frameList.append(benderDict[cname])
		result = du.ListDataFrame(frameList, columnNameList)
	else:
		result = benderDict
	
	return result
	

def ComputeSemiMinorAxis( efit, smarange=None ):
	"""For Bender-style ellipse-fits only!
	Re-computes semi-minor axis b, based on ellipticity and semi-major axis.
	Optionally, the range of semi-major axes for which b is recomputed can be
	specified via smarange (only semi-major axis values >= smarange[0] and 
	<= smarange[1] will be affected).
	"""
	
	if "intens" in efit.keys():
		print("*** Ellipse fit appears to be IRAF-style! ***")
		return None
	a = efit['a']
	ell = efit['eps']
	nRows = len(a)
	if smarange is not None:
		amin = smarange[0]
		amax = smarange[1]
		iGood = [ i for i in range(nRows) if a[i] >= amin and a[i] <= amax ]
	else:
		iGood = range(nRows)
		
	for i in iGood:
		efit['b'][i] = a[i] * (1.0 - ell[i])


